#!/usr/bin/env python

#  Copyright (c) 2010, Philip Busch <philip@0xe3.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#
#   - Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#   - Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.


import gtk
import gobject
from Xlib import X, display, error, Xatom, Xutil
import Xlib.protocol.event
from optparse import OptionParser


# number of pixels between outer border and the actual grid
padding = 2

# number of pixels between grid boxes
spacing = 1

# foreground color (inactive desktops)
color_inactive = '#333333'

# highlight color (the active desktop)
color_active = '#999999'

# background color ("transparent" for transparent background)
color_background = 'transparent'

# number of rows in desktop grid
rows = 2

# number of columns in desktop grid
columns = 3


class nap:
	def __init__(self):
		'''Initialization.'''
		# program info
		self.name = "neap"
		self.version = "0.2"
		self.author = ["Philip Busch <philip@0xe3.com>"]
		self.website = "http://code.google.com/p/neap/"

		# default config
		self.padding = 3
		self.spacing = 1
		self.color_active = "red"
		self.color_inactive = "green"
		self.color_background = "yellow"
		self.rows = 2
		self.columns = 3
		self.grid = []

		# menus
		self.menu_about = None

		self.display = display.Display()
		self.screen  = self.display.screen()
		self.root    = self.screen.root 

		self.desktop = self.get_desktop_names()

		self.pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, 20, 20)
		self.pixbuf.fill(0xffffffff)

		self.icon = gtk.StatusIcon()
		self.icon.set_from_pixbuf(self.pixbuf)
		self.update_pixbuf(self.get_current_desktop())

		self.icon.connect("activate", self.left)
		self.icon.connect("popup-menu", self.right)

		self.get_desktop_tasks(0)


	def get_desktop_tasks(self, num):
		'''Returns a list of tasks for desktop num.'''
		return self.root.get_full_property(self.display.intern_atom("_NET_CLIENT_LIST"), Xatom.WINDOW).value

	def get_current_desktop(self):
		'''Returns the index of the currently active desktop.'''
		return self.root.get_full_property(self.display.intern_atom("_NET_CURRENT_DESKTOP"), 0).value[0]

	def get_desktop_count(self):
		'''Returns the current number of desktops.'''
		return self.root.get_full_property(self.display.intern_atom("_NET_NUMBER_OF_DESKTOPS"), 0).value[0]

	def get_desktop_names(self):
		'''Returns a list containing desktop names.'''
		count = self.get_desktop_count()
		names = self.root.get_full_property(self.display.intern_atom("_NET_DESKTOP_NAMES"), 0)  
		if hasattr(names, "value"):
			names = names.value.strip("\x00").split("\x00")
		else:
			names = []
			for i in range(count):
				names.append(str(i)) 

		if len(names) < count:
			for i in range(len(names), count):
				names.append(str(i))  

		return names


	def update_grid(self):
		'''Updates internal grid structure.'''
		w, h = self.pixbuf.get_width(), self.pixbuf.get_height()

		n = max(self.rows, self.columns)
		c = (w - 2 * self.padding - (n - 1) * self.spacing) / self.columns

		grid_width = self.columns * c + (self.columns - 1) * self.spacing
		grid_height = self.rows * c + (self.rows - 1) * self.spacing

		off_x = (w - 2*self.padding - grid_width) / 2
		off_y = (h - 2*self.padding - grid_height) / 2

		grid = []
		for i in range(self.rows):
			for j in range(self.columns):
				x = off_x + self.padding + j*(c + self.spacing)
				y = off_y + self.padding + i*(c + self.spacing)

				if i * self.columns + j < len(self.desktop) :
					grid.append((x, y, c, c))

		self.grid = grid

	def update_pixbuf(self, active = -1):
		'''Updates internal icon pixbuf.'''
		self.update_grid()
		w, h = self.pixbuf.get_width(), self.pixbuf.get_height()

		map = gtk.gdk.Colormap(gtk.gdk.visual_get_best(), False)
		color_active       = map.alloc_color(self.color_active)
		color_inactive     = map.alloc_color(self.color_inactive)
		color_background   = map.alloc_color(self.color_background)

		pixmap = gtk.gdk.Pixmap(None, w, h, 32)
		gc = pixmap.new_gc()

		#---ACTUAL DRAWING CODE---
		gc.set_foreground(color_background)
		pixmap.draw_rectangle(gc, True, 0, 0, w, h)

		gc.set_foreground(color_inactive)

		i = 0
		for cell in self.grid:
			if(i == active):
				gc.set_foreground(color_active)
			else:
				gc.set_foreground(color_inactive)

			i = i + 1

			x, y, size_x, size_y = cell
			pixmap.draw_rectangle(gc, True, x, y, size_x, size_y)
		#-------------------------

		self.pixbuf.get_from_drawable(pixmap, map, 0, 0, 0, 0, w, h)
		self.pixbuf = self.pixbuf.add_alpha(True, 0x23, 0x57, 0xbd)
		self.icon.set_from_pixbuf(self.pixbuf)


	def get_screen(self):
		'''Returns the clicked grid box number.'''
		pointer_x, pointer_y, mods = self.icon.get_screen().get_root_window().get_pointer()

		screen, rectangle, orientation = self.icon.get_geometry()
		width, height, size_x, size_y = rectangle;

		pos_x = pointer_x - width
		pos_y = pointer_y - height

		i = 0
		for cell in self.grid:
			x, y, size_x, size_y = cell
			if pos_x >= x and pos_x <= x + size_x and pos_y >= y and pos_y <= y + size_y:
				return i
			i = i + 1

		return -1


	def left(self, status_icon):
		'''Callback for left-clicks.'''
		num = self.get_screen()

		if 0 <= num <= len(self.desktop):
			self.update_pixbuf(num)
			gobject.idle_add(self.switch_desktop, num)


	def switch_desktop(self, num):
		'''Sets the active desktop to num.'''
		win = self.root
		ctype = self.display.intern_atom("_NET_CURRENT_DESKTOP")
		data = [num]

		self.send_event(win, ctype, data)
		self.display.flush()


	def send_event(self, win, ctype, data, mask=None):
		'''Sends a ClientMessage event to the root window.'''
		data = (data+[0]*(5-len(data)))[:5]
		ev = Xlib.protocol.event.ClientMessage(window=win, client_type=ctype, data=(32,(data)))

		if not mask:
			mask = (X.SubstructureRedirectMask|X.SubstructureNotifyMask)
		self.root.send_event(ev, event_mask=mask)


	def desktop_callback(self, widget, data=None):
		'''Callback for the menu's desktop selector.'''
		if widget.get_active():
			self.switch_desktop(data)

	def get_menu_about(self):
		'''Returns a menu for the right-click action.'''
		menu = gtk.Menu()

		submenu = gtk.Menu()
		group = None
		i = 0
		for desktop in self.get_desktop_names():
			item = gtk.RadioMenuItem(group, desktop)

			if group == None:
				item.set_active(True)

			group = item
			item.connect("toggled", self.desktop_callback, i)
			i = i+1
			submenu.add(item)

		item = gtk.MenuItem("Desktops")
		item.set_submenu(submenu)
		menu.add(item)


		sep = gtk.SeparatorMenuItem()
		menu.add(sep)

		item = gtk.ImageMenuItem(gtk.STOCK_ABOUT)
		item.connect("activate", self.about)
		menu.add(item)

		#item = gtk.ImageMenuItem(gtk.STOCK_QUIT)
		#item.connect("activate", gtk.main_quit)
		#menu.add(item)

		self.menu = menu
		menu.show_all()
		return menu



	def right(self, status_icon, button, activate_time):
		'''Callback for right-clicks.'''
		if self.menu_about == None:
			self.menu_about = self.get_menu_about()

		self.menu_about.popup(None, None, gtk.status_icon_position_menu, 1, activate_time, self.icon)


	def about(self, menu_item):
		'''Shows an about dialog.'''
		about = gtk.AboutDialog()

		about.set_name(self.name)
		about.set_version(self.version)
		about.set_authors(self.author)
		about.set_comments("notification area / systray pager")
		about.set_copyright("Copyright (c) 2010 Philip Busch")
		about.set_website(self.website)
		about.set_logo(self.pixbuf)
		about.set_program_name(self.name)
		about.run()
		about.hide()


	def set_padding(self, padding):
		self.padding = int(padding)

	def set_spacing(self, spacing):
		self.spacing = int(spacing)

	def set_color_inactive(self, color):
		self.color_inactive = color

	def set_color_active(self, color):
		self.color_active = color

	def set_color_background(self, color):
		if color == "transparent":
			color = '#2357bd'

		self.color_background = color

	def set_rows(self, rows):
		self.rows = int(rows)

	def set_columns(self, columns):
		self.columns = int(columns)

	def main(self):
		num = self.get_current_desktop()
		self.update_pixbuf(num)
		gtk.main()


if __name__ == '__main__':
	parser = OptionParser()

	parser.add_option("-p", "--padding", dest="padding",
			  help="number of pixels between outer edge and grid",
			  metavar="N")

	parser.add_option("-s", "--spacing", dest="spacing",
			  help="number of pixels between rows/cols in the grid",
			  metavar="N")

	parser.add_option("-a", "--active-color", dest="color_active",
			  help="color of active desktop",
			  metavar="C")

	parser.add_option("-i", "--inactive-color", dest="color_inactive",
			  help="color of inactive desktop(s)",
			  metavar="C")

	parser.add_option("-b", "--background-color", dest="color_background",
			  help="background color",
			  metavar="C")

	parser.add_option("-r", "--rows", dest="rows",
			  help="number of grid rows",
			  metavar="N")

	parser.add_option("-c", "--columns", dest="columns",
			  help="number of grid columns",
			  metavar="N")

	(opts, args) = parser.parse_args()

	if opts.padding == None:
		opts.padding = padding

	if opts.spacing == None:
		opts.spacing = spacing

	if opts.color_active == None:
		opts.color_active = color_active

	if opts.color_inactive == None:
		opts.color_inactive = color_inactive

	if opts.color_background == None:
		opts.color_background = color_background

	if opts.rows == None:
		opts.rows = rows

	if opts.columns == None:
		opts.columns = columns


	nap = nap()

	nap.set_padding(opts.padding)
	nap.set_spacing(opts.spacing)
	nap.set_color_active(opts.color_active)
	nap.set_color_inactive(opts.color_inactive)
	nap.set_color_background(opts.color_background)
	nap.set_rows(opts.rows)
	nap.set_columns(opts.columns)

	nap.main()



